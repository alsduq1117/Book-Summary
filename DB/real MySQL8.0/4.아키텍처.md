# Real MySQL 8.0 - 4장
MySQL 서버 구분

- MySQL 엔진(두뇌)
    - 사용자 접속, 쿼리 요청을 처리, SQL 파싱 및 옵티마이저 담당하는 부분
- 스토리지 엔진(손,발)
    - InnoDB, MyISAM, Memory 등이 있다.
    - 데이터를 실제로 어떻게 저장하고 읽어올지 담당하는 부분
    - 각 테이블 마다 다른 종류의 스토리지 엔진을 사용하는것이 가능하다.

## MySQL의 전체 구조

![](https://velog.velcdn.com/images/alsduq1117/post/c3c291c3-9c3c-4c48-a83f-3b0b433fd1bf/image.png)


## 핸들러 API

MySQL 엔진에서 Inno DB와 같은 스토리지 엔진에 데이터 읽기, 쓰기 요청을 헨들러 요청이라고 한다.

따라서 MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽고자 할때 MySQL 엔진과 스토리지 엔진 사이에 데이터를 주고 받기 위해  ‘핸들러 API’ 를 사용하여 주고 받는다.

---

# **MySQL의 스레딩 구조**

MySQL 서버는 멀티 프로세스 기반이 아니라 멀티 스레드 기반으로 작동한다. 그리고 크게 포그라운드 스레드와 백그라운드 스레드로 나뉠수 있다.

## MySQL의 포그라운드 스레드(=클라이언트 스레드, 사용자 스레드)

사용자의 요청을 처리하는 스레드

데이터를 읽는 작업을 처리한다. 디스크에 직접 데이터를 쓰는 작업은 백그라운드 스레드에서 일어남.

데이터 캐시나 버퍼에서 데이터를 읽어오며, 만약 캐시나 버퍼에 데이터가 없으면 디스크나 인덱스파일에 데이터를 직접 읽어와 처리하기도 한다.

현재 MySQL에 접속된 클라이언트의 수 만큼 포그라운드 스레드가 존재한다.

### MySQL의 백그라운드 스레드

디스크에 데이터를 직접 기록하는 작업은 백그라운드 스레드에서 일어난다.

현재 로그나, 버퍼풀에 있는 데이터를 디스크에 기록

기록 이외에 데이터를 버퍼로 읽어오거나, 락, 데드락 모니터하는 백그라운드 쓰레드도 존재한다.

### MySQL(InnoDB)이 스레드를 포그라운드, 백그라운드로 나뉜 이유?

읽기 요청의 처리와 쓰기 요청의 처리를 분리하기 위함.

사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연되어 처리될 수 있지만, 데이터의 읽기 작업은 절대 지연될 수 없기 때문이다.

---

## **MySQL이 사용하는 메모리 영역**

MySQL 에서 사용하는 메모리 영역은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 나뉜다.

### 글로벌 메모리 영역

MySQL 시작시 운영체제로 부터 할당받는 클라이언트 수와 무관하게 할당받는 모든 스레드가 공유하는 메모리 영역

버퍼, 캐시를 위해 사용된다.

대표적으로 InnoDB의 버퍼풀이 있다.

### 로컬 메모리 영역 (=세션 메모리 영역, 클라이언트 메모리 영역)

포워드 스레드(=클라이언트 스레드)가 사용자의 쿼리를 처리하기 위해 사용하는 메모리 공간

로컬 메모리 영역은 스레드별로 독립적으로 할당되며 절대 공유되지 않는다.

대표적으로 커넥션 버퍼나 정렬이나, 조인할때 사용하는 버퍼 등이 있다.

커넥션 버퍼나 결과 버퍼는 커넥션이 열려있는 동안 계속 메모리 공간에 남아있으며, 조인이나 정렬할때 사용되는 버퍼는 쿼리를 실행하는 순간에만 메모리공간에 할당 되었다가 해제된다.

---

# **플러그인 스토리지 엔진 모델**

### 플러그인

MySQL에서 기본적으로 제공되는 기능 이외에 부가적인 기능을 더 제공하기 위한 방법으로 플러그인 모델을 사용한다.

InnoDB 또한 플러그인 형태로 제공되는 하나의 스토리지 엔진에 해당한다.

스토리지 엔진 뿐만아니라 3장에서 살펴보았던, 사용자 인증을위한 Native Authentication, Caching SHA-2 Authentication과 같은 인증 모듈들도 전부 플러그인이다.

### 스토리지 엔진 확인 하기 - SHOW ENGINES

![](https://velog.velcdn.com/images/alsduq1117/post/618750e8-1313-43db-b3d0-664567c337b5/image.png)

MySQL 서버에 포함되지 않은 스토리지 엔진을 사용하려면 MySQL 서버를 다시 빌드해야 한다. 하지만 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워넣기만 하면 손쉽게 사용할 수 있다.

### 플러그인 확인 하기 - SHOW PLUGINS;

![](https://velog.velcdn.com/images/alsduq1117/post/aa98b8d9-cee3-4e51-bb7b-df88693cdd45/image.png)


스토리지 엔진 뿐만 아니라 인증이나 전문 검색 파서, 쿼리 재작성과 같은 기능을 플러그인 형태로 지원한다.

---

## 컴포넌트(MySQL 8.0부터)

MySQL 8.0부터 플러그인 아키텍처를 대체하기 위해 등장한 개념

플러그인 아키텍처의 단점

⇒ 플러그인들 끼리 통신이 안되고, 플러그인끼리의 상호 의존관계 설정이 안됨

⇒ 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에(캡슐화가 안되어있음) 안전하지 않음

---

## 쿼리 실행 구조

1. 사용자 요청

2. 쿼리 파서에서 쿼리 문장을 토큰으로 분리해 트리형태의 구조로 재구성⇒ 쿼리 문장의 기본 문법 오류 발견

3. 전처리기 ⇒ 쿼리 구조적 오류, 테이블, 컬럼이름 검증, 권한 검증

4. 옵티마이저 ⇒ 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정

5. 쿼리실행기 ⇒ 옵티마이저에서 만든 계획대로 핸들러에게 실제 요청을 주고받음

6. 스토리지엔진 ⇒ 실제 데이터를 디스크로부터 읽고 쓰는 작업을 수행

---

## 복제

**데이터를 “물리적으로 다른 서버의 저장 공간” 안에 동일한 데이터를 복사하는 기술**

---

## 쿼리 캐시

빠른 응답을 위해 SQL 실행 결과를 캐싱해두는 기능

캐시 저장결과가 실제 데이터와 달라지면 모두 삭제 해야하는 문제가 발생하고 이 과정에서 성능저하 유발

결과적으로, 8.0 부터 쿼리 캐시는 MySQL 서버의 기능에서 제거 됨

---

## 스레드 풀

내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버의 자원 소모를 줄인다.

스레드 풀은 기본적으로 CPU 개수만큼 스레드 그룹을 생성하는데, 스레드 그룹의 개수는 thread_pool_size 시스템 변수를 변경해서 조정할 수 있다.

---

## 트랜잭션 지원 메타데이터

8.0 버전 부터는 ㄴ데이터베이스 서버에서 테이블의 구조정보 같은 메타데이터를  테이블에 모두 저장하도록 개선하여 기존의 파일 기반의 메타데이터 생성으로 인한 비정상 종료 시, 테이블이 깨지는 현상을 해결하였다.


---
# InnoDB 스토리지 엔진 아키텍처

InnoDB는 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이다.

** 추가

**잠금의 종류:**

**공유 잠금 (Shared Lock): 여러 트랜잭션이 동시에 같은 레코드를 읽을 수 있지만, 해당 레코드를 수정할 수는 없습니다.**

**배타적 잠금 (Exclusive Lock): 한 트랜잭션이 레코드를 수정할 수 있으며, 다른 트랜잭션은 해당 레코드를 읽거나 수정할 수 없습니다.**

---

## 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리키를 기준으로 저장된다.(프라이머리 키 값 순서대로 저장)
- 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다 (**세컨더리 인덱스 → 프라이머리 키 → 레코드 주소 값)**

> **세컨더리 인덱스는 특정 컬럼 값에 대한 프라이머리 키를 저장하고, 이 프라이머리 키를 통해 실제 레코드의 주소에 접근하는 구조**
>

****

- InnoDB에서는 모든 데이터는 프라이머리 키를 기준으로 정렬된 형태로 저장되어 있기 때문에 **인덱스 레인지 스캔**을 활용하면 데이터를 빨리 읽을 수 있다.
- MyISAM은 클러스터링 키를 지원하지 않기 프라이머리키와 세컨더리 인덱스 구분이 없고 모든 인덱스는 실제 데이터의 물리적인 주소값을 갖는다.

클러스터링

> 비슷한 데이터끼리 묶어서 보관하는것
>

세컨더리 인덱스

> 클러스터링 인덱스(PK 인덱스)를 제외한 모든 인덱스
>

---

## 외래 키 지원

외래 키의 경우 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로, MyISAM이나 MEMORY 스토리지엔진에서는 지원하지 않는 기능이다.

외래키 유의사항

외래 키 사용시, 부모 테이블과 자식 테이블 모두 인덱스를 생성해야 하고 변경 시, 여러 테이블에 잠금이 전파되는 문제와 데드락이 발생할때가 많아서 유의해야 한다.

### 외래 키 체크 기능 끄기

외래키가 복잡하게 얽혀있는 경우 데이터를 적재하거나 스키마 변경등의 관리 작업이 실패할 수 있다.

만약, 급하게 데이터를 처리해야 하는 경우 다음과 같이 외래 키 체크 기능을 끌 수 있다.

```vbnet
SET foreign_key_checks=OFF;

```

왜래 키 체크 키능을 끄고 작업을 수행 한 후 일관성이 맞춰졌다면, 다시 체크 기능을 켜주어야 한다.

```vbnet
SET foreign_key_checks=ON;

```

---

## MVCC(MultiVersion Concurrency Control)

> 하나의 레코드에 대해 여러개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조
>

InnoDB는 언두 로그(Undo log) 를 이용해 이 기능을 구현한다.

![](https://velog.velcdn.com/images/alsduq1117/post/951de93f-0790-4c75-8c40-6e396e756ccf/image.png)

1. member 테이블 생성
2. INSERT 문을 이용해 member 삽입
1. InnoDB 버퍼 및 디스크에 데이터 존재 , undo 로그 x
3. UPDATE 문을 이용해 area 를 ‘서울’로 수정(그림)
1. InnoDB의 버퍼 풀은 새로운 값인 ‘서울’로 업데이트 된다.
2. undo 로그에 기존의 area 인 ‘경기’를 가지고 있는다
4. SELECT 문을 이용해 변경된 데이터를 조회 해보면 어떤 어떻게 될까?

> MySQL 서버의 시스템 변수에 설정된 격리 수준(transaction_isolation)에 따라 다르다!
>

격리 수준

Isolation Level은 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`이 존재하며 갈수록 동시성(성능)이 낮아지지만 독립성과 정합성이 높아질 수 있다.

```jsx
READ_UNCOMMITED ⇒ 락이 걸려있어도 아직 커밋되지 않은 데이터도 읽겠다.
READ_COMMITED ⇒ 락이 걸려있어도 이전 커밋된 상태 까지의 데이터만 읽겠다.
REPEATABLE_READ ⇒ 자신보다 이전 트랜잭션ID 에서 변경까지만 읽겠다. Inno DB의 기본값
SERIALIZABLE ⇒ 락이 걸려있으면 락이 회수 될때까지 기다렸다가 읽겠다.
```

READ_COMMITTED , REPEATABLE_READ(Default), SERIALIZABLE 인 경우에는 커밋이나 롤백중에 데이터를 조회하게 되면 언두 영역의 데이터를 반환 한다.

---

### 잠금 없는 일관된 읽기( Non-Locking Consistent Read)

![](https://velog.velcdn.com/images/alsduq1117/post/a89b07a5-a071-4295-8669-d7ee2fcd5666/image.png)

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.

특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라고 Undo 로그를 사용하여 변경 되기 전의 데이터를 읽어 잠금 없이 읽기가 가능하다.

---

## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 교착 상태에 빠지지 않았는지 체크하기 위해 목록(Wait-for list)을 관리한다

데드락에 걸린 트랜잭션 중 어느 트랜잭션을 먼저 종료할지는 언두 로그를 더 적게 가져 부하가 적은 트랜잭션을 선택하여 강제 종료한다.

동시 처리 스레드가 매우 많을 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모하게 된다. 따라서

innodb_deadloct_detect 시스템변수를 off 하여 데드락 감지를 종료하고 timeout 을 통해 에러메시지를 반환하도록 하여 해결할 수 있다.

---

## 자동화된 장애 복구

MySQL이 갑자기 종료되어 완료되지 못한 트랜잭션이나 디스크에 일부만 써진 데이터(Partial Write)가 존재한다면 InnoDB 는 서버를 재시작 할 때 이러한 부분을 자동으로 복구한다.

### 자동화된 장애 복구가 안될 경우

디스크나 서버 하드웨어 이슈로 서버를 재시작 할**때 자동화된 복구가 수행되지 않을 수 있다.** 이 경우 자동복구를 멈추고 MySQL 서버는 종료되어 버린다.

이때는 **innodb_force_recovery 시스템 변수를 설정한 후 MySQL 서버를 재시작** 해야한다.

- 로그 파일이 손상 되었을 경우, innodb_force_recovery를 6으로 설정 후 재시작
- 테이블 데이터 파일이 손상 되었을 경우, innodb_force_recovery를 1로 설정 후 재시작
- 어떤 부분이 손상되었는지 모를 경우에는 1부터 6까지 변경하면서 재시작
    - innodb_force_recovery 값이 커질수록 심각한 상황
- 그래도 재시작 되지 않으면, 백업을 이용해 DB를 다시 구축해야 한다.

---

## InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분

디스크 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간

쓰기 작업을 일괄처리 할수 있는 버퍼 역할도 한다. ⇒ INSERT, UPDATE, DELETE 와 같은 쓰기 작업을 모아서처리

### 버퍼 풀의 크기 설정

처음으로 MySQL 서버를 준비한다면,

보통 처음에 운영체제의 전체 메모리의 50% 정도에서 시작해서 올려나가면서 최적점을 찾는다.

버퍼 풀의 크기는 innodb_buffer_pool_size 시스템 변수로 변경할 수 있고, MySQL 서버가 한가한 시점에 작업을 진행하는것이 좋다.

### 버퍼 풀의 구조

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기(innodb_page_size 시스템 변수의 설정된 크기) 조각으로 쪼개어 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.

버퍼 풀은 페이지 조각을 관리하기 위해 다음과 같이 3개의 자료구조를 관리한다.

- LRU(Least Recently Used) 리스트 - 가장 오랫동안 사용되지 않은 페이지가 먼저 교체됨

![](https://velog.velcdn.com/images/alsduq1117/post/f9531627-df35-4d54-88ea-9228cebcd58d/image.png)

각 페이지는 얼마나 최근에 접근했는지에 따라 Age 값이 부여됨.

새로운 페이지는 Old 리스트의 헤드 부분(5/8 지점)에 추가

한번 읽힌 페이지는 Age가 초기화 되고 New 리스트 의 헤드쪽으로 이동(MRU - Most Recently Used)

사용하지 않는 페이지는 Old 리스트의 꼬리쪽으로 이동(LRU)

- 플러시 리스트

디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다.

일단 한번 변경이 일어난 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록해야 한다.

- 프리 리스트

InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지의 목록
