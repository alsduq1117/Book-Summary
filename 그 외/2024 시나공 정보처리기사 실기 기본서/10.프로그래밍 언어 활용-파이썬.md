# 10장.프로그래밍 언어 활용 - 파이썬

# 4. 파이썬

## 01. 파이썬 기본 구조

- 파이썬은 사용자 정의 함수, 클래스가 먼저 정의되고, 그 다음에 실행 코드
- 가독성을 위해 들여쓰기를 함

```python
def fn(num):
  if num % 2 == 0:
    return 'Y'

class A:
  def fn(self):
    print('A')

print('Hello') # Hello
```

## 02. 자료형 ⭐⭐⭐

### 1) 자료형 유형

| 유형 | 설명 | 세부 유형 |
| --- | --- | --- |
| 기본 자료형(Primitive Data Type) | 직접 자료를 표현하는 자료형 | 숫자형(Number)논리형(Logical) |
| 컬렉션 자료형(Collection Data Type) | 다수의 데이터를 효과적으로 처리 | 문자열형(String)리스트형(List)튜플형(Tuple)딕셔너리형(Dictionary)세트형(Set) |

### 2) 컬렉션 자료형(Collection Data Type)

- 시퀀스 자료형(순서 O)

| 유형 | 설명 | 예시 |
| --- | --- | --- |
| 문자열형(String) | - 문자 한 개 또는 여러 개 저장하고자 할 때 사용 | `s = "Test"` |
| 리스트형(List) | - 크기가 가변적으로 변하는 선형리스트의 성질을 가짐- 읽기, 쓰기 모두 가능 | `I=[1, 2, 3]` |
| 튜플형(Tuple) | - 초기에 선언된 값에서 값을 생성, 삭제, 수정할 수 없는 형태- 읽기 전용으로 속도가 빠름 | `t=(1, 2, 3)` |
- 비시퀀스 자료형(순서 X)

| 유형 | 설명 | 예시 |
| --- | --- | --- |
| 세트형(Set) | - 중복된 원소를 허용하지 않는 집합의 성질을 가짐 | `s={1, 2, 3}` |
| 딕셔너리형(Dictionary) | - 키, 값으로 구성된 객체를 저장하는 구조 | `d={'s':1, 'j':2, 'b':3}` |

→ 파이썬의 **세트형**은 자바의 Set 클래스(**HashSet**)과, 파이썬의 **리스트형**은 자바의 List 클래스(**ArrayList, LinkedList**)와, 파이썬의 **딕셔너리형**은 자바의 Map 클래스(**HashMap**)와 비슷

### ① 시퀀스 자료형 구조

1. 시퀀스 자료형 종류

   ⓐ 문자열형(String) ⭐

    ```python
    print("Hello")
    print("Hello", "World") # Hello World ← (,)로 구분되면 띄어쓰기
    print("\"Hello\"") # "Hello"
    print("Hello"*3) # HelloHelloHello
    ```

    - 파이썬 문자열은 포맷스트링을 이용하여 문자열을 출력할 수 있음

        ```python
        a = "Hello"
        print("%s" % a) # Hello
        b = "%s" % " world"
        print(a+b) # Hello world
        c = 123
        print("%s %d" % (a, c)) # Hello 123
        ```

      → 컬렉션 자료형 변수를 그냥 출력했을 때는 괄호 표시 O, 문자열 변수를 출력했을 때는 괄호 표시 X

    - 문자열에서 `in` 연산자를 이용하여 찾고자 하는 문자열이 존재하면 `True`, 없으면 `False`
    - 문자열 관련 함수


        | 함수 | 설명 |
        | --- | --- |
        | `upper()` | 문자열을 대문자로 변환 |
        | `lower()` | 문자열을 소문자로 변환 |
        | `isalnum()` | 문자열이 알파벳 또는 숫자로만 구성되어 있는지 |
        | `isalpha()` | 문자열이 알파벳으로만 구성되어 있는지 |
        | `isdecimal()` | 문자열이 정수인지 |
        | `isdigit()` | 문자열이 숫자인지 |
        | `isspace()` | 문자열이 공백으로만 구성되어 있는지 |
        | `split()` | 문자열을 매개변수로 전달된 문자(구분자)로 나누어 리스트로 변환 |
        
        ```python
        str = "1,2,3".split(",")
        print(str) # ['1', '2', '3']
        ```
        
    
    ⓑ 리스트형(list) ⭐⭐
    
    - [,] 를 이용하여 리스트형 선언
        - `리스트명=[요소1, 요소2, ···]`
    - 리스트형 메서드
        
        
        | 메서드 | 설명 |
        | --- | --- |
        | `append(x)` | 리스트 마지막 요소 뒤에 값 x를 추가 |
        | `clear()` | 리스트의 모든 항목을 삭제 |
        | `copy()` | 리스트를 복사 |
        | `count(x)` | 리스트에서 x 항목의 개수를 알려줌 |
        | `extend(i)` | 리스트 마지막에 컬렉션 자료형 i를 추가 |
        | `index(x)` | 값 x와 같은 값을 가지고 있는 인덱스 번호를 알려줌 |
        | `insert(i, x)` | 리스트의 i 번지 위치에 값 x를 삽입 |
        | `pop()` | 마지막 항목을 삭제하고 값을 꺼내옴 |
        | `remove(x)` | 리스트에서 해당하는 값(중복이면 가장 앞) x를 제거 |
        | `reverse()` | 리스트의 위치를 전부 역순으로 바꿔줌 |
        | `sort()` | 리스트의 항목들을 정렬 |
    - 리스트를 2차원으로 만들 수 있음
        
        ```python
        a = [[1, 2], [3, 4], [5, 6]]
        print(a) # [[1, 2], [3, 4], [5, 6]]
        print(a[0]) # [1, 2]
        print(a[1][0]) # 3
        b = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
        print(b[0]) # [1, 2, 3]
        ```
        
    
    ⓒ 튜플형
    
    - (,) 를 이용하여 리스트형 선언
        - `튜플명=(요소1, 요소2, ···)`
        
        ```python
        t = ('s', 'j', 'b')
        print(t) # ('s', 'j', 'b')
        ```

2. 시퀀스 자료형 요소 접근 방벙 - 인덱싱(Indexing)
    - 시퀀스 자료형은 여러 값으로 이루어져 있는데 인덱스를 이용해서 중간값에 접근할 수 있음


        | 첫 번째 요소 | 두 번째 요소 | ··· | 뒤에서 두 번째 요소 | 뒤에서 첫 번째 요소 |
        | --- | --- | --- | --- | --- |
        | 0 | 1 | ··· | (n-2) | (n-1) |
        | -n | -(n-1) | ··· | -2 | -1 |
    - 인덱싱은 문자열, 리스트 같은 자료구조에서 사용
    - 문자열 인덱싱은 문자열에 부여된 번호로 원하는 문자를 가리킬 때 사용
    - 문자열 앞에서부터 시작하면 인덱스는 0부터 시작하고, 뒤에서부터 시작하면 -1 부터 시작
    - 인덱싱으로 접근하면 출력 결과에 괄호가 없음
3. 시퀀스 자료형 요소 접근 방벙 - 슬라이싱(Slicing)
    - 슬라이싱은 시퀀스 자료형에서 여러 개의 데이터에 동시에 접근하는 기법
    - `시퀀스변수명[시작 : 종료 : 스텝]`


        | 형태 | 설명 |
        | --- | --- |
        | 시작 | - 슬라이싱을 **시작**할 인덱스- 생략할 경우 '시퀀스변수명[ : 종료]' 또는 '시퀀스변수명[ : 종료 : 스텝]' 형태가 됨- 생략할 경우 처음부터 슬라이싱 |
        | 종료 | - 슬라이싱을 **종료**할 인덱스- 종료 인덱스에 있는 인덱스 전까지만 슬라이싱- 생략할 경우 '시퀀스변수명[ 시작 : ]' 또는 '시퀀스변수명[ 시작 : : 스텝]' 형태가 됨- 생략할 경우 마지막까지 슬라이싱 |
        | 스텝 | - 몇 개씩 끊어서 슬라이싱을 할지 결정하는 값- 생략할 경우 '시퀀스변수명[ 시작 : 종료 ]' 또는 '시퀀스변수명[ 시작 : 종료 : ]' 형태가 됨- 생략할 경우 1이 기본값 |
    
    ⓐ 문자열 슬라이싱
    
    ```python
    print("Information"[1:]) # nformation
    print("Information"[2:4]) # fo
    print("Information"[:3]) # inf
    ```
    
    → 문자열 슬라이싱을 제외한 다은 시퀀스 자료형은 출력 결과에 괄호가 표시됨
    
    ⓑ 리스트 슬라이싱
    
    ```python
    a = [4, 2, 7, 3, 5]
    print(a[0 : 4 : 2] # [4, 7]
    ```
    
    ⓒ 튜플 슬라이싱
    
    ```python
    t = ('s', 'j', 'b')
    print(t[1:]) # ('j', 'b')
    ```


### ② 비시퀀스 자료형 구조

1. 세트형

   ⓐ 세트(Set)형 개념

    - 중복된 원소를 허용하지 않는 자료형으로 순서가 중요하지 않음
    - set라는 키워드로 세트형을 초기화하거나 {, }를 이용하여 선언

    ```
    세트명 = set([요소1, 요소2, ···])
    세트명 = {요소1, 요소2, ···}
    ```

   ⓑ 세트형 메서드

   | 메서드 | 설명 |
       | --- | --- |
   | `add(값)` | 값을 1개 추가 |
   | `update([값1, 값2, ···])` | 여러 개의 값을 한꺼번에 추가 |
   | `remove(값)` | 특정 값을 제거하는 메서드 |
2. 딕셔너리(Dictionary)

   ⓐ 딕셔너리형 개념

    - 키와 값으로 구성된 객체를 저장하는 구조

   ⓑ 딕셔너리형 요소 생성

    - `딕셔너리명={키1:값1, 키2:값2, ···}`
    - {, } 안에 콜론(:)을 이용하여 키와 값을 구분하여 선언

   ⓒ 딕셔너리형 요소 변경

    - `딕셔너리명[키]=값`
    - 기존 변수에 키와 값을 추가
    - 기존 변수에 해당 키에 해당하는 값이 있었으면 값을 변경

   ⓓ 딕셔너리형 요소 삭제

    - 기존 변수에서 해당 키와 키에 해당하는 값을 삭제
    - `del 딕셔너리명[키]`

### ③

### 3) 자료형 함수

### ① type 함수

- 자료형을 확인하는 함수
- 기본 자료형(Primitive Data Type)


    | 세부 유형 | 출력 |
    | --- | --- |
    | 정수형(Integer) | <class 'int'> |
    | 실수형(Floating Point) | <class 'float'> |
    | 논리형(Logical) | <class 'bool'> |
- 컬렉션 자료형(Collction Data Type)


    | 세부 유형 | 출력 |
    | --- | --- |
    | 문자열형(String) | <class 'str'> |
    | 리스트형(List) | <class 'list'> |
    | 튜플형(Tuple) | <class 'tuple'> |
    | 딕셔너리형(Dictionary) | <class 'dict'> |
    | 세트형(Set) | <class 'set'> |

### ② len 함수

- 컬렉션 자료형의 크기를 계산하는 함수

## 03. 입출력 ⭐

### 1) 표준 출력 함수(print)

### ① 단순 출력 및 개행

- `print(문자열)` : 출력 후에 개행
- `print(문자열, end='')` : 출력 후에 개행을 하지 않음

### ② 변수 출력

- `print(변수명)`

### 2) 표준 입력 함수(input)

- 파이썬에서는 정수형이나 실수형과 같은 숫자를 입력받을 때는 문자열로 저장한 후에 `eval` 함수를 써서 숫자를 변환해 주어야 함
    - 문자열 입력 : `변수명 = input()`
    - 숫자 입력 : `변수명 = eval(변수명)`

```python
  s = input() # 1
  s = eval(s)
  print(s) # 1
```

## 04. 연산자 ⭐⭐

- 프로그램 실행을 위해 연산을 표현하는 기호

### 1) 연산자 종류

### ① Swap 연산자

- 두 변수의 값을 교환하는 연산자
- 콤마를 기준으로 두 값을 교환

```python
a, b = 10, 20
print(a) # 10
print(b) # 20
a, b = b, a
print(a) # 20
print(b) # 10
```

→ 파이썬 연산자는 C언어와 거의 동일하지만 ++, --는 지원하지 않음

### ② 산술 연산자

- 두 수의 수치 계산을 위한 연산자
- 사칙 연산(+, -, *, /, //), 지수 연산(**), 나머지 연산(%)

```python
print(3 / 2) # 1.5
print(3 // 2) # 1 ← 몫 계산
print(3 ** 2) # 9
print(3 % 2) # 1
```

### ③ 대입 연산자

- 변수에 값을 할당하는 연산자
- '+=', '-=', '*=', '/=' 은 C나 Java와 동일하며, 파이썬에는 추가적으로 '**=', '//=' 연산자 제공

## 05. 조건문과 반복문

- 파이썬에서는 switch 문이 없음
- 파이썬에서는 do-while 문이 없음

### 1) for 문

- in 연산다 뒤에 range 함수를 사용하여 반복의 범위를 지정하거나 리스트 개수만큼 반복을 수행

① 일반 for 문

- range 함수는 범위를 지정하는 함수
- range 함수에서 시작을 생략하면 0, 스텝 값을 생략하면 1이 자동으로 들어감

```python
for 변수 in range(시작, 종료, 스텝) :
  명령문
```

② for each 문

- 시퀀스 자료형의 요소들을 차례대로 변수에 대입하면서 반복하는 명령어

```python
for 변수 in 시퀀스자료형 :
  명령문
```

- 파이썬 for each 문

```python
li = [1, 2, 3, 4, 5]
for a in li :
  print(a) # 1\n2\n3\n4\n5\n
```

- 파이썬 이중 for each 문

```python
li = [[1, 2], [3, 4, 5]]
for a in li :
  for b in a :
    print(b, end='') # 12345
```

## 06. 함수 ⭐⭐

### 1) 사용자 정의 함수

① 사용자 정의 함수(User-Defined Function)

- 사용자가 직접 새로운 함수를 정의하여 사용하는 방법
- 사용자 정의 함수에서 매개변수나 생성된 변수는 사용자 정의 함수가 종료되면 없어짐

```python
def 함수명(변수명, ···) :
  명령어
  return 반환값
```

② 디폴트 매개변수

- 기본값이 정의된 매개변수
- 함수를 호출할 때, 매개변수가 명시외더 있지 않으면 디폴트 매개변수 값이 전달

```python
def 함수명(매개변수=디폴트값) :
  명령문
```

### 2) 람다 함수

① 람다 함수

- 함수 이름 없이 동작하는 함수
- 매개변수에 값을 전달하면 표현식에서 연순을 수행

② 람다 함수 문법

1. 일반 람다 함수

```python
lambda 매개변수 : 표현식
```

- 일반 사용자 정의 함수는 def 키워드와 return 키워드를 사용하여 함수를 구현

```python
(lambda n, m : n + m)(2, 3) # 5 (왜 출력이 되는거지?)
```

1. 변수를 이용한 람다 함수
- 람다 함수를 변수에 할당하여 재사용할 수 있음

```python
sum = lambda n, m : n + m
print(sum(2, 3)) # 5
```

1. 사용자 정의 함수를 이용한 람다 함수
- 람다 함수는 사용자 정의 함수로 구현할 수 있음

```python
def f(n) :
  return lambda a:a*m
k = f(3)
print(k(10)) # 30
```

1. 내장 함수를 이용한 람다 함수 ⭐
- 람다 함수는 파이썬 map 함수, filter 함수와 같이 사용 가능


    | 함수 | 형태 | 설명 |
    | --- | --- | --- |
    | `map` | map(함수, 리스트) | - 첫 번째 매개변수에는 함수, 두 번째 매개변수에는 리스트를 전달- 리스트 요소를 함수에 전달하여 반복을 수행하는 함수 |
    | `filter` | filter(함수, 리스트) | - 첫 번째 매개변수에는 함수, 두 번째 매개변수에는 리스트를 전달- 리스트 요소를 함수에 전달하여 조건이 참인 값을 리턴하는 함수 |
- 파이썬 map을 이용한 람다 함수

```python
a = [1, 2, 3, 4, 5]
m = list(map(lambda num : num + 100, a))
print(m) # [101, 102, 103, 104, 105]
```

- 파이썬 filter를 이용한 람다 함수

```python
a = [1, 2, 3, 4, 5]
m = list(filter(lambda num : num > 2, a))
print(m) # [3, 4, 5]
```

## 07. 예외 처리 ⭐

### 1) 예외 처리

① 예외 처리

- 작성한 코드가 실행하는 도중에 발생되는 에러를 처리하는 구문
- try, except, finally를 이용하여 예외 처리

```python
try :
  명령문
except :
  예외 발생시 동작할 명령문
```

→ except 다음에 예외가 발생하는 경우 동작할 코드 작성

```python
try :
  명령문
except 발생예외명:
  예외 발생시 동작할 명령문
finally :
  명령문
```

→ except에서 특정 예외만 처리하기 위함

→ finally는 try가 실행되고 마지막에 반드시 실행될 명령문

```python
try :
  명령문
except 발생예외명1:
  예외 발생시 동작할 명령문1
except 발생예외명2:
  예외 발생시 동작할 명령문2
else :
  명령문
```

→ else는 예외가 발생되지 않았을 경우에 실행될 명령문

```python
a, b = 2, 0
try :
  print(a/b)
except IndexError as e :
  print('[exception]', e)
except ZeroDivisionError as e :
  print('[exception]', e) # [exception] division by zero
```

② raise

- 프로그램이 의도하지 안헤 동작하는 것을 방지하기 위해 의도적으로 예외를 발생시키는 명령
- try except 구분 안에서도 사용 가능

```python
명령문
raise
```

```python
명령문
raise 예외처리명
```

```python
명령문
raise 예외처리명("메시지")
```

```python
a, b = 2, 0
try :
  print(a/b)
  raise
except ZeroDivisionError as e :
  print('에러') # 에러
```

## 08. 클래스

### 1) 클래스

- 객체 지향 프로그래밍(OOP; Object-Oriented Programming)에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀

### 2) 클래스 정의

- 클래스에서 변수는 변수 선언과 동일, 메서드는 사용자 정의 함수와 문법 동일

```python
class 클래스명:
  def 메서드명(self, 변수명, ···):
    명령어
    return 반환값
```

- 파이썬에서는 함수명에 입력받을 값(매개변수) 앞에 self라는 키워드를 적어야 함

```python
class Test:
  def fn(self):
    print(5)
```

### 3) self

- self는 현재 객체를 가리키는 키워드
- 클래스 내부의 변수와 함수를 가리킬 수 있음

```python
self.변수명
self.함수명(매개변수)
```

```python
class Test:
  def setS(self, a):
    self.a = a
  def getS(self):
    return self.a
a = Test()
a.setS(5)
print(a.getS()) # 5
```

### 4) 생성자(Constructor) ⭐

- 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류의 메서드
- 생성자는 `__init__`이라는 메서드 명을 사용하고, 첫 번째 매개변수로 `self`를 작성하며, 반환 값이 없음
- 생성자 정의

```python
class 클래스명:
  def __init__(self, 매개변수):
    명령어
```

- 생성자 호출 : `클래스변수=클래스(매개변수)`

### 5) 소멸자(Destructor)

- 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용되는 메서드
- 소멸자는 `__del__`이라는 메서드명을 사용하고, 첫 번째 매개변수에 `self`를 작성하며, 반환 값이 없음
- 소멸자 정의

```python
class 클래스명:
  def __del__(self):
    명령어
```

- 소멸자 호출 : `del 클래스변수`

```python
class Test:
  def __init__(self):
    print("생성자")
  def __del__(self):
    print("소멸자")
  def fn(self):
    print("일반함수")

t = Test() # 생성자
t.fn() # 일반함수
del t # 소멸자
```

### 6) 클래스 접근 제어자

- 파이썬은 `private`, `public` 등의 접근 제어자 키워드가 존재하지 않고 작명법(Naming)으로 접근 제어를 해야 함

| 종류 | 규칙 | 설명 |
| --- | --- | --- |
| public | - 밑줄이 접두사에 없어야 함 | - 외부의 모든 클래스에서 접근이 가능한 접근 제어자 |
| protected | - 한 개즤 밑줄 _이 접두사여야 함 | - 같은 패키지 내부에 있는 클래스, 하위 클래스(상속받은 경우)에서 접근이 가능한 접근 제어자- 자기 자신과 상속받은 하위 클래스 둘 다 접근이 가능한 접근 제어자 |
| private | - 두 개의 밑줄 __이 접두사여야 함 | - 같은클래스 내에서만 접근이 가능한 접근 제어자 |

## 09. 클래스 상속

### 1) 클래스 상속(Inheritance)

- 상속은 어떤 객체가 있을 때 그 객체의 변수와 메서드를 다른 객체가 물려받는 기능

```python
class 부모_클래스명:
···
class 자식_클래스명(부모_클래스명):
···
```

### 2) 메서드 오버라이딩(Overriding)

- 오버라이딩은 하위 클래스에서 상위 클래스 메서드를 재정의할 수 있는 기능
    - 오버라이드하고자 하는 메서드가 상위 클래스에 존재하여야 함
    - 메서드 이름은 같아야 함
    - 메서드 매개변수 개수, 데이터 타입이 같아야 함

```python
class 부모_클래스명:
  def 메서드명(self, 변수명) :
    명령어
class 자식_클래스명(부모_클래스명):
  def 메서드명(self, 변수명) : # 부모 클래스와 메서드명, 매개변수가 같아야 함
    명령어
```

```python
class A:
  def fn(self) :
    print('A')
class B(A):
  def fn(self) :
    print('B')
a = B()
a.fn() # B
```

### 3) 부모 클래스 접근

- 파이썬은 super 키워드를 이용하여 상위 클래스의 변수나 메서드에 접근할 수 있음

```python
super().메서드명()
```

```python
class A:
  def fn(self) :
    print('A')
class B(A):
  def fn(self) :
    super().fn()
    print('B')
a = B()
a.fn() # A\nB\n
```