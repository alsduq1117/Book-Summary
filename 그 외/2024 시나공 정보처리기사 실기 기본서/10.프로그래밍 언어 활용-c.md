# 10장.프로그래밍 언어 활용 - C 언어

# 1. 프로그래밍을 위한 기본 사항

## 01. 진수

### 1) 진수(Antilogarithm)

- 특정 개수의 숫자만을 이용하여 수를 나타내는 수 체계

### 2) 진수 변환

① 10진수를 n진수로 변환

- 10진수 값을 몫이 작은 n보다 작을 때까지 n으로 나누고 나머지 값들을 표시한 후에 나머지 값들을 읽음

② n진수를 10진수로 변환

- n진수에서 마지막 자리는 자리 숫자에 자릿값인 n0을 곱하고, 마지막에서 두 번째 자리는 자리 숫자에 자릿값인 n1을 곱하고, 마지막에서 세 번째 자리는 자리 숫자에 자릿값인 n2을 곱하고, ··· 자리 숫자와 자릿값을 더해 10진수를 계산

### 3) 아스키 코드

① 아스키 코드

- 미국 ANSI에서 표준화한 정보교환용 부호체계
- 영문 키보드로 입력할 수 있는 모든 기호가 할당된 기본적인 부호체계

② 주요 아스키 코드

| 10진수 | 부호 | 10진수 | 부호 | 10진수 | 부호 |
| --- | --- | --- | --- | --- | --- |
| 0 | NULL | 65 | A | 97 | a |
| 32 | ' '(Space) | 66 | B | 98 | b |
| 48 | 0 | 67 | C | 99 | c |
| 49 | 1 | 68 | D | 100 | d |

# 2. C언어

## 01. C언어 기본

### 1) C언어 기본 구조

- C언어는 본문 전에 처리하는 전처리 부분과 본문으로 구성되어 있음
- 헤더는 xxx.h 파일로, 헤더 안에는 프로그래밍에 필요한 함수가 포함

### 2) 전처리기

① 전처리기(Preprocessor)

- 실행 파일을 생성하는 과정에서 소스 파일 내에 존재하는 전처리 지시문을 처리하는 작업

② 전처리기 종류

- `#include` : C언어 프로그램에 **헤더 파일**을 포함할 때 사용하는 전처리기
- `#define` : **매크로**를 정의할 때 사용하며, **상숫값**을 지정하기 위한 예약어로 구문의 상수로 치환할 때 사용하는 전처리기

## 02. 자료형 ⭐

### 1) 자료형

- 프로그래밍 언어에서 실숫값, 정숫값과 같은 여러 종류의 데이터를 식별하는 형태
- **메모리 공간**을 효율적으로 사용하고 **2진수 데이터**를 다양한 형태로 사용하기 위해 존재

### 2) 자료형 유형

| 유형 | 설명 | 선언 형식 |
| --- | --- | --- |
| 문자(Character) | - 문자 하나를 저장- 메모리에 저장은 숫자로 | char |
| 정수(Integer) | - 정숫값을 저장 | int |
| 부동 소수점(Floating Point) | - 소수점을 포함하는 실숫값 저장 | float, double |

## 03. 식별자 ⭐

### 1) 식별자

- 변수, 상수, 함수 등 서로 구분하기 위해 사용되는 이름
- 프로그램의 구성요소를 구별하기 위해 사용

### 2) 식별자 명명 규칙

| 구분 | 규칙 | 사용 가능 예시 | 사용 불가능 예시 |
| --- | --- | --- | --- |
| 사용 가능 문자 | - 영문 대문자/소문자, 숫자, 밑줄 사용 가능 | a, A, a1, _, _hello | ?a, <a |
| 변수 사용 규칙 | - 첫 자리에는 숫자 사용 불가- 변수 이름 중간에 공백 사용 불가 | _1, a1, a100my_student | 1, 1a, 1A, 1234my student |
| 변수 의미 부여 | - 이미 사용되고 있는 예약어의 경우 변수 사용 불가 | For, If, While | int, shor, long, ··· |

> 에약어
>
>
> 이미 문법적인 용도로 사용되고 있는 단어
>

### 3) 식별자 표기법

| 표기법 | 설명 | 예시 |
| --- | --- | --- |
| 카멜 표기법(Camel Case) | - 여러 단어가 이어지면 첫 단어 시작만 **소문자**로,각 단어의 첫 글자는 **대문자**로 지정 | inputFunction |
| 파스칼 표기법(Pascal Case) | - 여러 단어가 이어지면 각 단어의첫 글자는 **대문자**로 지정하는 표기법 | InputFunction |
| 스네이크 표기법(Snake Case) | - 여러 단어가 이어지면 단어 사이에**언더바**를 넣는 표기법 | input_function |
| 헝가리안 표기법(Hungarian Case) | - **두어**에 자료형을 붙이는 표기법- int 형일 경우 n, char 형일 경우 c,문자열일 경우 sz를 붙임 | nScore |

## 04. 변수 ⭐⭐

### 1) 변수(Variable)

- 저장하고자 하는 어떠한 값이 있을 때, 그 값을 주기억장치에 기억하기 위한 공간

### 2) 변수 선언(Variable Declaration)

- 변수나 함수가 있음을 알려주는 행위
- 변수가 어떤 자료형을 사용할지 알려주기 위해 사용
    - 초기화하지 않는 경우 : `자료형 변수명;`
    - 초기화하는 경우 : `자료형 변수명=초깃값;`

### 3) 변수 유효범위(Variable Scope)

① 전역 변수(Global Variable)

- 어떤 블록에도 속하지 않은 변수

  > 블록(Block) : C언어에서 중괄호로 묶는 부분
>
- 프로그램이 시작되면 변수가 생성되고, 프로그램이 종료되면 변수가 소멸
- 초기화하지 않으면 정수형은 0, 실수형은 0.0, 문자형은 NULL로 초기화
- 아무 곳에서나 사용 가능

② 지역 변수(Local Variable)

- 블록 내에서 선언하는 변수
- 블록이 시작되는 부분에 바로 선언해주어야 하고, 중괄호가 닫히는 시점에 소멸
- 해당 블록 안에서만 사용 가능

③ static 변수(초기화용)

- 블록 내외부 상관없이 선언할 수 있는 변수
- 변수 선언할 때 static이라는 키워드를 붙임
- 블록 내외부 상관없이 프로그램이 시작되면 변수가 생성되고, 프로그램이 종료되면 변수 소멸
- 전역 변수로 선언할 경우 프로그램 전체에서, 블록 내에 선언할 경우 블록 내에서만 사용 가능

## 05. 표준 입출력 함수 ⭐⭐

### 1) 표준 출력 함수(printf)

- printf는 지정된 지정된 포맷 스트링으로 데이터를 출력하는 함수

① 단순 출력

```
printf(문자열);
```

② 이스케이프 문자를 이용한 출력

- **이스케이프 문자**는 문자열 내에서 특수한 기능을 수행하는 문자
- 특수한 기능을 수행하기 위해서 이스케이프 문자를 printf 함수의 큰 따옴표 안에 넣음
    - `\n` (New Line) : 커서를 다음 줄 앞으로 이동(개행)
    - `\t` (Tab) : 커서를 일정 간격만큼 수평 이동

③ 포맷 스트링을 이용한 변수 출력

- 일반적으로 scanf를 통해 사용자로투버 입력을 받아들이거나 printf를 통해 결과를 출력하기 위해 사용하는 형식
- 인자에는 변수명, 값, 수식이 올 수 있음

```
printf(포맷_스트링이_포함된_문자열, 인자, ···);
```

| 유형 | 표현 | 의미 | 설명 |
| --- | --- | --- | --- |
| 문자(Character) | %c | Character | - 문자 1글자에 대한 형식 |
| 문자열(String) | %s | String | - 문자가 여러 개인 문자열에 대한 형식 |
| 정수(Integer) | %u%d%o%x, %X | Unsigned DecimalDecimalOctalHexa Decimal | - 부호 없는 10진수 정수- 10진수 정수-8진수 정수-16진수 정수(%x일땐 영어가 소문자로, %X일땐 대문자로 표시) |
| 부동 소수점(Floating Point) | %e, %E%f%lf | ExponentFloating PointLong Floating Point | - 지수 표기(%e는 지수표현을 e로, %E는 E로 표시)- 부동 소수점 표기- 부동 소수점 표기 |

④ 포맷 스트링을 이용한 변수 상세 출력

- 포맷 스트링을 이용해 정렬, 0 채우기, 출력할 공간 확보, 소수점 자릿수 표기를 지정 가능

```
%[-][0][전체자리수].[소수점자리수]스트링
```

| 포맷 스트링 | 설명 |
| --- | --- |
| [−] | - [−]를 붙이면 왼쪽 정렬- [−]를 붙이지 않고, [전체자리수]가 정해져 있을 경우 오른쪽 정렬 |
| [0] | - 0을 붙이면 전체 자릿수에서 앞에 빈공간 만큼 0으로 채움 |
| [전체자리수] | - [전체자리수]만큼 공간이 확보됨- 소수점(.)도 한 자릿수로 포함됨 |
| .[소수점자리수] | - [소수점자리수]만큼 소수점이 출력됨- 실수형일 때만 적용됨 |

### 2) 표준 입력 함수(scanf)

- 키보드로 입력받은 문자열에서 지정된 포맷 스트링으로 데이터를 읽는 함수
- scanf의 포맷 스트링은 printf의 포맷 스트링과 동일

```
scanf(포맷_스트링이_포함된_문자열, 변수의_주솟값, ···);
```

> scanf를 사용하기 위해서는 stdio.h 헤더를 선언해야함
>

## 06. 연산자 ⭐⭐⭐

### 1) 연산자(Operator)

- 프로그램 실행을 위해 연산을 표현하는 기호

### 2) 연산자 종류

- 증감 연산자(++,−−) : 피연산자를 1씩 증가 혹은 1식 감소시킬 때 사용
- 산술 연산자(+, −, *, /, %) : 산술식을 구성
- 시프트 연산자(<<, >>) : 비트를 이동
- 관계 연산자(>, <, >=, <=, ==, !=) : 두 피연산자 사이의 크기를 비교
- 비트 연산자(&, |, ^, ~) : 비트 단위로 논리 연산할 때 사용
- 논리 연산자(&&, ||, !) : 두 피연산자 사이의 논리적인 관계 정의
- 삼항 연산자((조건식)? (참):(거짓)) : 조건이 참일 경우 (참) 값을, 거짓일 경우 (거짓) 값을 반환
- 대입 연산자(=, +=, -=, *=, /=, %=) : 변수(왼쪽)에 값(오른쪽)을 대입할 때 사용

### 3) 연산자 우선순위

- 증산시 관비논삼대

| 우선순위 | 연산자 | 유형 |
| --- | --- | --- |
| 1 | x++, x-- | 증감 |
| 2 | ++x, --x!~ | 증감*논리*비트 |
| 3 | *, /, % | 산술 |
| 4 | +, - | 산술 |
| 5 | <<, >> | 시프트 |
| 6 | <, <=, >, >= | 관계 |
| 7 | ==, != | 관계 |
| 8, 9, 10 | &, ^, | | 비트 |
| 11, 12 | &&, || | 논리 |
| 13 | (조건식)? a:b | 삼항 |
| 14 | =, +=, -=, *=, /=, %= | 대입 |

### 4) 연산자 상세

① 증감 연산자(Increment & Decrement Operator)

| 종류 | 설명 |
| --- | --- |
| ++x | 변수의 값을 1 증가시킨 후에 해당 변수를 사용 |
| x++ | 변수를 사용한 후에 변수의 값을 1 증가 |
| −−x | 변수의 값을 1 감소시킨 후에 해당 변수를 사용 |
| x−− | 변수를 사용한 후에 변수의 값을 1 감소 |

② 산술 연산자

| 종류 | 설명 |
| --- | --- |
| + | 양쪽의 값을 더하는 연산자 |
| − | 왼쪽 값에서 오른쪽 값을 빼는 연산자 |
| * | 두 개의 값을 곱 |
| / | 왼쪽 값을 오른쪽 값으로 나눔 |
| % | 왼쪽 값을 오른쪽 값으로 나눈 나머지를 계산(정수만 가능) |

③ 시프트 연산자(Shift Operator) ⭐

- <<로 1비트 이동시킬 때마다 2배씩 증가하게 되고, >>로 1비트 이동시킬 때마다 2배씩 감소

| 종류 | 설명 |
| --- | --- |
| << | 양쪽의 값을 더하는 연산자 |
| >> | 왼쪽 값에서 오른쪽 값을 빼는 연산자 |

④ 관계 연산자(Relation Operator)

- 참이면 1을, 거짓이면 0을 반환

⑤ 비트 연산자(Bit Operator)

| 종류 | 설명 |
| --- | --- |
| & | 두 값을 비트로 연산하여 같은 비트의 값이 **모두 1**이면 **해당 비트 값이 1**이 되고, **그렇지 않으면 0**이 되는 연산자(AND 연산자) |
| | | 두 값을 비트로 연산하여 같은 비트의 값이 **하나라도 1**이면 **해당 비트 값이 1**이 되고, **그렇지 않으면 0**이 되는 연산자(OR 연산자) |
| ^ | 두 값을 비트로 연산하여 같은 비트의 값이 **서로 다르면 해당 비트 값이 1**이 되고, **그렇지 않으면 0**이 되는 연산자(XOR 연산자) |
| ~ | 모든 비트의 값을 **반대로** 바꾸는 반전 기능을 하는 연산자(NOT 연산자)⭐ 부호를 반대로 바꾼 값에 1을 뺀 값 |
- AND 연산자는 피연산자가 모두 True인 경우에만 결과가 True, 그외에는 모두 False인 연산자
- OR 연산자는 피연산자가 모두 True인 경우에만 결과가 True, 그외에는 모두 False인 연산자

⑥ 논리 연산자(Logig Operator)

- 참이면 1, 거짓이면 0 반환

⑦ 삼항 연산자(Ternary Operator)

```
조건식 ? 참일때값 : 거짓일때값;
```

⑧ 대입 연산자(Assignment Operator)

- 변수(왼쪽)에 값(오른쪽)을 대입할 때 사용

## 07. 조건문

- 조건의 참, 거짓 여부에 따라 실행 경로를 달리하는 if 문과 여러 경로 중에 하나를 선택하는 switch 문으로 구분

### 1) if 문

```c
if(조건문){
  명령문;
}
```

### 2) switch 문

```c
switch (식){
  case 값:
    명령문;
    break;
  default:
    명령문;
```

- 식을 계산해서 일치하는 값을 가진 case 문을 실행
- 식이 어떠한 값도 만족하지 않으면 default로 진입
- ⭐ **break가 존재하지 않을 경우** break를 만날 때까지 switch 문에 있는 다른 문장 실행

## 08. 반복문

- 특정 부분을 조건이 만족할 때가지 실행하도록 하는 명령문
- 반복문을 사용할 때 특별한 조건이 없으면 무한 처리를 반복(무한 루프)함

### 1) while 문

```c
while(조건문){
  명령문;
}
```

### 2) do while 문

```c
do{
  명령문;
}while(조건문);
```

- 참, 거짓과 관련 없이 무조건 한 번은 실행하고, 그 다음부터는 조건이 참인 동안에 해당 분기를 반복해서 실행하는 명령문

### 3) for 문

```c
for (초기식; 조건식; 증감식){
  명령문;
}

명령문;
```

- 초기식, 조건식, 증감식을 지정하여 반복

### 4) 루프 제어 명령문

① break 문

- 반복문이나 switch 문을 중간에 탈출하기 위해 사용하는 명령어

② continue 문

- 반복문에서 다음 반복으로 넘어갈 수 있도록 하는 명령어

## 09. 배열 ⭐⭐⭐

### 1) 배열(Array)

- 같은 자료형의 변수들로 이루어진 집합

### 2) 배열 종류

① 1차원 배열

- 초기값이 없는 경우 : 자료형 배열명[배열*요소*개수];
- 초기값이 있는 경우 : 자료형 배열명[배열*요소*개수] = {초깃값};

```c
int a[3] = {1, 2};
int 데이터가 들어갈 공간 = 배열값;
```

- 배열 요소 개수에 정의된 숫자만큼 같은 자료형의 데이터 공간 할당
- 초깃값을 선언하지 않으면 쓰레깃값이 저장
- 배열 요소 개수보다 **적은 개수만큼 초기화**하면 정수형일 경우 0으로, 실수형일 경우 0.0으로, 문자형일 경우 NULL로 초기화
    - NULL의 아스키코드는 0

② 2차원 배열

- 초기값이 없는 경우 : 자료형 배열명[행의_개수][열의_개수];
- 초기값이 있는 경우 : 자료형 배열명[행의_개수][열의_개수] = {초깃값};

```c
int a[2][3] = {1, 2, 3, 4};
```

- (행의 개수)×(열의 개수)에 정의된 숫자만큼 같은 자료형의 데이터 공간 할당
- 초깃값을 선언하지 않으면 쓰레깃값 저장

## 10. 문자열 ⭐⭐⭐

### 1) 1차원 배열과 문자열

- C언어에서는 문자열은 char 형 배열로 표현
- 문자열을 초기화할 때 **마지막 NULL 문자가 삽입**되므로 초기화하는 글자 수보다 1 이상 큰 값으로 배열을 선언(초기화할 때 배열의 크기를 명시하지 않으면 문자열의 문자 수+1만큼 자동 생성)
- printf 함수에서 %s를 이용하여 문자열을 읽고 출력하는데, printf 파라미터로 문자를 읽기 시작할 시작 주소를 알려주면 시작 주소부터 **NULL 직전 값까지 읽어서 출력**

```c
#include <stdio.h>void main(){
  char a[8] = "Hello";
  printf("%s\n", a); // Hello
  printf("%s\n", a+1); // ello
  a[3] = NULL;
  printf("%s\n", a+1); // el
  printf("%s\n", a+4); // o
}
```

`char a[8] = "Hello";`

| a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] |
| --- | --- | --- | --- | --- | --- | --- | --- |
| H | e | l | l | o | NULL | NULL | NULL |

`a[3] = NULL;`

| a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] |
| --- | --- | --- | --- | --- | --- | --- | --- |
| H | e | l | NULL | o | NULL | NULL | NULL |

→ ⭐ printf는 NULL 직전 값까지 읽어서 출력

→ ⭐ `printf("%s\n", a);` 에서 `a` 대신에 `&a[0]`으로, `printf("%s\n", a+1);` 에서 `a+1` 대신에 `&a[1]`로 `printf("%s\n", a+4);` 에서 `a+4` 대신에 `&a[4]`로 바꿔도 결과는 같음

### 2) 2차원 배열과 문자열

- 여러 개 정의할 때 char 형 2차원 배열을 사용

```c
#include <stdio.h>void main(){
  char a[2][8] = {"Hello", "Stranger"};
  printf("%s\n", a[0]) // Hello
  printf("%s\n", a[1]) // Stranger
  printf("%s\n", a[1]+3) // anger
  a[1][4] = NULL;
  printf("%s\n", a[1]+2) // ra
```

`char a[2][8] = {"Hello", "Stranger"};`

|  | a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| a[0] | H | e | l | l | o | NULL | NULL | NULL |
| a[1] | S | t | r | a | n | g | e | r |

`a[1][4] = NULL;`

|  | a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| a[0] | H | e | l | l | o | NULL | NULL | NULL |
| a[1] | S | t | r | a | NULL | g | e | r |

→ ⭐ `printf("%s\n", a[0]);` 에서 `a[0]` 대신에 `&a[0][0]`으로, `printf("%s\n", a[1]);` 에서 `a[1]` 대신에 `&a[1][0]`로 `printf("%s\n", a[1]+2);` 에서 `a[1]+2` 대신에 `&a[1][2]`로 바꿔도 결과는 같음

## 11. 구조체 ⭐⭐

### 1) 구조체

- 사용자가 기본 자료형을 가지고 새롭게 정의할 수 있는 사용자 정의 자료형

### 2) 구조체 선언

```c
struct 구조체명{
  자료형 변수명1;
  자료형 변수명2;
  ···
};
```

- 구초체는 `구조체변수.변수명` 형태로 값을 가리킴

```c
#include <stdio.h>struct Student {
  char gender;
  int age;
};

void main(){
  struct Student s = {'F', 21};
  s.gender = 'M';
  printf("%c", s.gender); // M
  printf("%d", s.age); // 21
```

## 12. 함수 ⭐⭐⭐

### 1) main 함수

① main 함수

- main 함수는 프로그램이 실행하는 모든 프로그램의 시작점
- main 함수에 있는 명령어를 실행

② main 함수 형태

```c
자료형 main(파라미터){
  명령어;
}
```

- **`void main()`** 일 경우 반환할 값이 없으므로 `return;` 을 사용하거나 return 자체를 사용하지 않고, **`int main()`** 일 경우 `return 반환값;` 을 명시해주어야 함
- main 함수나 사용자 정의 함수는 `return` 을 만나면 그 즉시 함수를 종료

```c
void main(){
  return;
}
```

```c
int main(){
  return 반환값;
}
```

> void
>
> - 함수를 호출한 호출자에게 결괏값을 제공하지 않는다는 의미의 자료형
> - void는 '존재하지 않음'이라는 뜻으로 반환 값이 없다는 의미로 사용

### 2) 사용자 정의 함수

① 사용자 정의 함수(User-Defined Function)

- 사용자가 직접 새로운 함수를 정의하여 사용하는 방법
- **매개변수**나 생성된 변수는 사용자 정의 함수가 종료되면 없어짐

② 사용자 정의 함수 선언

```c
자료형 함수명(자료형 변수명, ···){
  명령어;
  return 반환값;
}
```

③ 매개변수 전달 방법

- 매개변수 전달 방법은 함수가 필요로 하는 값을 매개변수로 만들면 함수를 호출하는 쪽에서 매개변수를 사용하여 해당 함수에게 변수의 값, 변수의 주솟값을 전달하는 방식
- 매개변수 전달 방법 구성 요소

| 구성요소 | 설명 |
| --- | --- |
| 전달인자(Argument) | - 실 매개변수(Actual Parameters)로도 불림- 함수를 호출하는 쪽에서 전달하는 변수의 값 또는 변수의 주솟값 |
| 매개변수(Parameter) | - 형식 매개변수(Formal Parameters)로도 불림- 함수를 호출하는 쪽에서 전달하는 변수의 값 또는 변수의 주솟값 |

```c
#include <stdio.h>int fn(int x, int y){ // → 매개변수
  ···
}

void main(){
  int i, j;
  ···
  fn(i, j); // → 전달인자
}
```

- ⭐ 매개변수 전달 방법 종류

| 구성요소 | 설명 | 예시 |
| --- | --- | --- |
| Call by Value | - 변수의 값을 넘겨주고, 이 값은 새로운 공간에 할당되어 사용하는 방식- 형식 매개변수의 어떠한 변화도 실 매개변수에 아무런 영향을 미치지 않음 | `#include <stdio.h>int fn(int x, int y){···}void main(){int i, j;···fn(i, j);}` |
| Call by Reference | - 변수의 값이 아닌 변수가 사용 중인 메모리 공간의 주소를 넘겨주는 방식- 실 매개변수의 주소를 형식 매개변수로 보냄 | `#include <stdio.h>int fn(int* x, int* y){···}void main(){int i, j;···fn(&i, &j);}` |

④ 재귀 함수

- 재귀 함수는 함수 자신이 자신을 부르는 함수
- 재귀 함수 선언

```c
자료형 함수명(자료형 변수명, ···){
···
함수명(변수명, ···)
···
return 반환값;
```

### 3) 표준 함수

① 문자열 함수 #include<string.h>

**1. strcat(String Concatenate)**

- 문자열끼리 연결하는 함수
    - `strcat(dest, src);` : `src` 의 문자열을 `dest` 문자열 뒤에 붙임
    - `strncat(dest, src, maxlen);` : `src` 의 문자열에서 `maxlent`의 개수만큼 `dest` 문자열 뒤에 붙임

**2. strcpy(String Copy)**

- 문자열을 복사하는 함수
    - `strcpy(dest, src);` : `src`의 문자열을 `dest` 문자열에 복사
    - `strncpy(dest, src, maxlen);` : `src`의 무자열에서 `maxlent`의 개수만큼 `dest` 문자열에 복사

**3. strcmp(String Compare)**

- 문자열을 비교하는 함수
    - `strcmp(s1, s2);` : `s1`, `s2`의 대소를 비교
    - `strncmp(s1, s2, maxlent);` : `maxlen` 길이만큼만 `s1`, `s2`의 대소를 비교
- 문자열에 대해서 ASCII 코드를 비교하여 `s1`이 `s2`보다 크면 1을, `s1`과 `s2`가 같으면 0을, `s1`이 `s2`보다 작으면 -1을 반환

**4. strlen(String Length)**

- 문자열의 길이를 알려주는 함수
    - `strlen(s);` : s의 길이를 알려줌

**5. strrev(String Reverse)**

- 문자열을 거꾸로 뒤집는 함수
    - `strrev(str);` : str 내에 문자열을 거꾸로 뒤집음

**6. strchr**

- 문자열 내에 일치하는 문자가 있는지 검사하는 함수
    - `strchr(str, c);` : str 내에 c가 존재하면 첫번째 c의 위치를 반환

② 수학 함수 #include<math.h>

**1. sqrt**

- 양의 제곱근을 계산하는 함수
    - `sqrt(n)`; : *n* 의 값을 계산

> 양의 제곱근은 소수를 확인할 때도 사용한다. a라는 값의 소수를 확인할 때는 2 ~ (a-1)의 모든 정수들로 나눴을 때 나누어 떨어지지 않는지 확인하는 것이 정석이지만, sqrt를 이용하면 2 ~ a의 정수들만 나누어 떨어지지 않는지 확인하면 소수를 구할 수 있기 때문이다.
>

**⭐ 2. ceil**

- 소수점 올림 함수
    - `ceil(n);` : 소수점 올림

**⭐ 3. floor**

- 소수점 내림 함수
    - `floor(n);` : 소수점 내림

③ 유틸리티 함수

**1. rand(Random)** #include<stdlib.h>

- 임의의 값을 생성하는 함수
    - `rand();` : 임의의 정숫값 1개를 생성

**2. srand(Seed Random)** #include<stdlib.h>

- 난수 생성 알고리즘에 사용하는 seed를 정해주는 함수
- `srand`를 사용하면 `rand` 함수를 사용할 때 해당 seed 값에 해당하는 난수 패턴으로 생성
    - `srand(seed);` : seed 값에 따라 난수 발생기를 초기화

**3. time** #include<time.h>

- 현재 시간을 가져오는 함수
- 1970년 1월 1일 이후로 몇 초가 경과했는지를 나타냄`time(NULL);` : time 함수에 파라미터를 NULL로 하면 현재 시간을 리턴

```c
#include <stdio.h>#include <stdlib.h>#include <time.h>void main() {
  int a;
  int i;
  srand(time(NULL));
  for(i=0; i<6; i++){
    a = rand()%45+1;
    printf("%d ", a); // 29 2 43 25 4
  }
}
```

> rand() 함수는 임의로 난수만 생성하기 때문에 여러 번 실행하면 동일한 숫자가 나올 수 있음
>

**4. atoi(ASCII to Integer)** #include<stdlib.h>

- 문자열을 정수형으로 변환하는 함수
    - `atoi(str)` : 문자열(str)을 정수(int)형으로 변환

```c
#include <stdio.h>#include <stdlib.h>void main() {
  char *a = "1";
  int num = atoi(a);
  printf("%d ", num); // 1
}
```

> 문자열을 저장하기 위해서 일반적으로 배열을 사용하지만, 문자형 포인터를 생성하면서 문자열을 대입할 수 있음
>

**5. atof(ASCII to Floating Point)** #include<stdlib.h>

- 문자열을 실수형으로 변환하는 함수
    - `atof(str)` : 문자열(str)을 실수형(float, double)형으로 변환

**⭐ 6. itoa(integer to ASCII)**

- 정수형을 문자열로 변환하는 함수
    - `itoa(value, str, radix)` : value를 변환하여 str에 radix 진수로 저장

## 13. 포인터 ⭐⭐⭐

### 1) 포인터

- 변수의 주솟값을 저장하는 공간

### 2) 포인터 선언

```
자료형* 포인터_변수명 = &변수명;
```

- 자료형 뒤에 *를 붙이면 주소를 저장하는 포인터 변수, 일반 변수명에 &를 붙이면 해당 변수명의 주솟값
- 주소에 해당하는 값을 가리키는 * 연산과 변수에 주솟값을 나타내는 & 연산은 반대 기능 → *(&) 는 상쇄

```c
#include <stdio.h>void main() {
  int a = 10;
  int* b = &a;
  printf("%d %d %d", a, *b, *(&a))); // 10 10 10
}
```

### ⭐ 3) 배열과 포인터

- `자료형 배열명[요소];` 일 때 다음 코드는 동일
    - 배열의 i번지 주소 : 배열+i == &배열[i];
    - 배열의 i번지 값 : *(배열+i) == 배열[i];

① 1차원 배열과 1차원 포인터

- 1차원 배열에서 배열명만 단독으로 사용할 경우 1차원 포인터와 동일
- 1차원 배열일 때는 배열명[요소] 형태, *(배열명+요소)일 경우 값을 가리키고, 1차원 포인터일 때는 포인터[요소] 형태,* (포인터+요소)일 경우 값을 가리킴

```c
#include <stdio.h>void main() {
  int a[3] = {1, 2};
  int *p = a;
  printf("%d %d %d\n", a[0], *b, *(&a))); // 10 10 10
}
```

② 2차원 배열과 1차원 포인터

- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일
- 2차원 배열일 때는 배열명[요소] 형태, *(배열명+요소)는 1차원 포인터와 동일하고, 1차원 포인터에 대해 *과 []을 이용해야 값을 가리킬 수 있음

```c
#include <stdio.h>void main() {
  int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
  int *p = a[1];
  printf("%d %d %d\n", *a[0], *a[1], *a[2]); // 1 3 5
  printf("%d %d %d\n", **a, **(a+1), **(a+2)); // 1 3 5
  printf("%d %d\n", *p, *(p+1)); // 3 4
  printf("%d %d\n", p[0], p[1]); // 3 4
}
```

③ 2차원 배열과 포인터 배열

```c
#include <stdio.h>void main() {
  int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
  int *p[3] = {a[2], a[0], a[1]};
  printf("%d %d %d\n", a[0][0], a[1][0], a[2][0]); // 1 3 5
  printf("%d %d %d\n", *a[0], *a[1], *a[2]); // 1 3 5
  printf("%d %d %d\n", p[0][0], p[1][0], p[2][0]); // 1 3 5
  printf("%d %d %d\n", *p[1], *p[2], *p[0]); // 1 3 5
}
```

④ 2차원 배열과 2차원 포인터

- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일
- 2차원 배열일 때 배열명[요소][요소], *배열명[요소], **(배열명+요소)일 경우 값을 가리킴
- ⭐ 2차원 포인터는 `int **p, **q;` 형태로 선언할 수 있으나 2차원 포인터 p, q는 2차원 배열에서 한 덩어리의 크기를 알 수 없기 때문에 열의 개수를 명시하는 형태로 포인터 변수를 선언
- ⭐ 포인터 변수 선언할 때 괄호가 없으면 2차원 배열에 대한 포인터가 아닌 포인터 배열이 됨
    - `자료형 (*포인터 변수)[열의 크기];`

```c
#include <stdio.h>void main() {
  int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
  int (*p)[2] = a;
  int (*q)[2] = a+1;
  printf("%d %d %d\n", a[0][0], a[0][1], a[1][0]); // 1 2 3
  printf("%d %d %d\n", p[0][0], p[0][1], p[1][0]); // 1 2 3
  printf("%d %d %d\n", q[0][0], q[0][1], q[1][0]); // 3 4 5
}
```

### ⭐ 4) 구조체와 포인터

① 구조체 변수와 구조체 포인터

- 구조체는 **일반 구조체 변수**로 접근할 때는 **`.`** 으로 접근하고, **구조체 포인터**로 접근할 때는 **`>`** 로 접근

```c
#include <stdio.h>
Struct Student{
  char gender;
  int age;
}
void main() {
  struct Student s = {'F', 21};
  struct Student *p = &s;
  printf("%c %d\n", s.gender, s.age); // F 21
  printf("%c %d\n", (&s)->gender, (&s)->age); // F 21
  printf("%c %d\n", p->gender, p->age); // F 21
  printf("%c %d\n", (*p).gender, (*p).age); // F 21
  printf("%c %d\n", p[0].gender, p[0].age); // F 21
}
```

② 1차원 구조체 배열과 1차원 구조체 포인터 ⭐

- 1차원 구조체 배열에서 배열명만 단독으로 사용할 경우 1차원 구조체 포인터와 동일
- 1차원 구조체 배열일 때 배열명[요소].변수명 형태, (*(배열명+요소)).변수명, 배열명->변수명 형태, (배열명+요소)->변수명 형태로 값을 가리킴
- 1차원 포인터일 때 포인터[요소].변수명 형태, (*(포인터+요소)).변수명, 포인터->변수명 형태, (포인터+요소)->변수명 형태로 값을 가리킴

```c
#include <stdio.h>
Struct Student{
  char gender;
  int age;
}
void main() {
  struct Student s[3] = {'F', 21, 'M', 20, 'M', 24};
  struct Student *p = &s;
  printf("%c %d\n", s[0].gender, s[0].age); // F 21
  printf("%c %d\n", (*s)->gender, (*s)->age); // F 21
  printf("%c %d\n", s->gender, s->age); // F 21
  printf("%c %d\n", (s+1)->gender, (s+1)->age); // M 20
  printf("%c %d\n", p[0].gender, p[0].age); // F 21
  printf("%c %d\n", (*p).gender, (*p).age); // F 21
  printf("%c %d\n", p->gender, p->age); // F 21
  printf("%c %d\n", (p+1)->gender, (p+1)->age); // M 20
}
```

### ⭐ 5) 함수 포인터

- 함수의 주소를 저장하고, 해당 주소의 함수를 호출하는 데 사용하는 포인터

```
리턴타입 (*함수_포인터)(함수 파라미터);
```

```c
#include <stdio.h>void fn1(){
  printf("fn1 함수\n");
}
int fn2(int a){
  printf("fn2 함수: %d\n", a);
  return 0;
}
void main(){
  void (*pf1)();
  int (*pf2)(int);
  fn1(); // fn1 함수
  fn2(5); //fn2 함수: 5
  pf1 = fn1;
  pf2 = fn2;
  pf1(); // fn1 함수
  pf2(2); //fn2 함수: 2
```