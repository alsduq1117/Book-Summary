# 코딩 테스트 사전 준비

문제를 분석하는 단계에서 충분히 예외 테스트 케이스를 추가 해보기

## 0. 코딩 테스트를 준비하기 전에

1. 기록하라

(문제를 풀지는 못했지만) 어디까지 생각해봤는지 우선 기록해두기

2. 시험 보듯 공부하라

주어진 시간을 효율적으로 사용하여 최대의 점수를 내는 것을 목표로 하기.

3. 짧은 시간 공부해서는 절대 코딩 테스트를 통과할 수 없다.

4.나만의 언어로 요약하라

정말 이해했는지 확인하는 방법은 이해한 내용을 요약해보는 것이다.

---

## 1. 코딩 테스트 효율적으로 준비하기

> 언어 선택하기
>

언어는 코딩 테스트에서 그렇게 중요한 요소는 아니다. 자신이 가장 잘할 수 있는 언어를 고르면 된다.

언어를 활용할 때는 다음 내용만 기억하면 된다.

- 변수 선언하기
- 함수 정의하기
- 컬렉션 자료형 다루기
- 조건문,반복문 사용하기

> 문제 분석 연습하기
>

코딩 테스트는 문제 풀이 능력을 확인하는 것이 핵심이다.

문제 분석에도 시간을 충분히 사용해야 하낟. 대부분 2~4시간 정도 문제 풀 시간을 주므로 전체 시간의 50%~60% 정도는 문제 분석에 시간을 쓰는 것이 좋다.

1. 문제를 쪼개서 분석하라
    1. 동작 단위로 쪼개서 분석
2. 제약 사항을 파악하고 테스트 케이스를 추가하라
3. 입력값을 분석하라
4. 그리디하게 접근할 때는 근거를 명확히 해라
5. 데이터 흐름이나 구성을 파악하라.
    1. 삽입과 삭제가 빈번 → 힙
    2. 데이터 값의 차이가 크면 배열의 인덱스로 활용하는 건 피하기

> 의사 코드로 설계하는 연습하기
>

의사 코드: 프로그램의 논리를 설명하고 알고리즘을 표현하기 위해 작성한 일종의 지침.

- 원칙 1 : 프로그래밍 언어로 작성하면 안됨
- 원칙 2 : 일반인도 이해할 수 있는 자연어로 작성해야 함
- 원칙 3 : 일정한 형식이 없음(자유롭게 작성)

1. 세부 구현이 아닌 동작 중심으로 작성하라.
2. 문제 해결 순서로 작성하라.
    1. 영어 석정 입력 → 영어 성적이 60점을 넘는지 확인 → 넘으면 통과, 미만이면 실패
3. 충분히 테스트 하라.

---

## 3. 알고리즘의 효율 분석

시간복잡도 : 알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다.

> 알고리즘 수행 시간을 측정하는 방법
>
- 절대 시간을 측정하는 방법 : 시간을 그대로 측정
- 시간 복잡도를 측정하는 방법
    - 입력 크기에 따른 연산 횟수의 추이를 활용해서 시간 복잡도를 표현
    - 빅오 표기법 : 최악의 경우데 대하여 시간 복잡도를 표현하는 방법(최고차항만 남기고 계수 지우기)
        - 로그함수 < 다항함수 < 지수함수

> 시간 복잡도를 코딩 테스트에 활용하는 방법
>

코딩 테스트 문제에는 제한 시간이 있으므로 문제를 분석한 후에 `빅오 표기법`을 활용해서 해당 알고리즘을 적용했을 때 제한 시간 내에 출력값이 나올 수 있을지 확인해볼 수 있다.

> 시간 복잡도 계산해보기
>

문제 정의 → 연산 횟수 측정 → 시간 복잡도 분석

---

## 4.코딩 테스트 필수 문법

프리미티브 타입 : int, long, float, double

레퍼런스 타입 : Integer , Long, Float, Double

레퍼런스 타입은 참조형 변수이므로 프리미티브 타입보다 연산 속도가 더 느리다.

> 정수형
>

양과 음의 정수, 0을 포함

```java
- 정수형 변수 선언
int a = 13

- 정수형 산술 연산
System.out.println(a+b);
System.out.println(a-b);
System.out.println(a*b);
System.out.println(a/b);
System.out.println(a%b);

- 정수형 비교 연산
System.out.println(a == b);   같은 값인지 비교
System.out.println(a != b);
System.out.println(a > b);
System.out.println(a < b);

- 정수형 비트 연산
System.out.println(a & b); AND
System.out.println(a | b); OR
System.out.println(a ^ b); XOR
System.out.println(~a); NOT
System.out.println(a << 2); 왼쪽 시프트
System.out.println(a >> 2); 오른쪽 시프트
```

> 부동소수형
>

- 엡실론을 포함한 연산에 주의하라

자바는 부동소수형 데이터를 이진법으로 표현하기 때문에 오차가 발생한다 이를 `엡실론` 이라고 한다.

코딩 테스트에서 부동소수형 데이터를 다룰 일이 생겼을 때 이 엡실론을 항상 생각해야 한다.

단순 a==b 를 하게 되면 의도한 결과가 나오지 않고

```java
if (Math.abs(a-b) < epsilon)
```

다음과 같이 비교해야 의도한 결과가 나오게 된다.

> 컬렉션 프레임 워크
>

- 배열 : 저장할 데이터의 개수가 정해져 있을때 사용하기 유용

```java
int[] array = { 1,2,3,4,5 };
int[] array = new int[] { 1,2,3,4,5 };
int[] array = new int[5];
```

- 리스트 : 자바의 리스트는 일반적으로 ArrayList 를 의미한다
    - ArrayList 는 가변 크기이므로 새 데이터의 삽입 혹은 기존 데이터의 삭제를 할 수 있다.
    - 맨 뒤에 데이터를 추가 시 O(1) 이지만, 중간에 삽입 시 O(N)까지 커질 수 있다.

```java
ArrayList<Integer> list = new ArrayList();
list.add(1);
list.add(2):

System.out.println(list.get(2));
System.out.println(list);
```

- 해시맵 : 키와 값 쌍을 저장하는 해시 테이블로 구현

```java
HashMap<String, Integer> map = new HashMap<>();

//해시맵 값 삽입
map.put("apple", 1);

//해시맵 값 출력
System.out.prinln(map);

//데이터 검색
if(map.containsKey(key)){
	int value = map.get(key);
	System.out.println(key + ": " + value);
}
else { 
	System.out.println(key + "는 해시맵에 없습니다.");
}

//해시맵 삭제
map.remove("orange");
```

- 문자열 : 문자들을 배열의 형태로 구성한 이뮤터블 객체
    - 이뮤터블 객체 :  값을 변경할 수 없는 객체, 시간 복잡도 관점에서 사용 시 주의

```java
String string = "Hello World";

String string = "He";
//문자열 추가
string += "llo";   
//문자열 수정
string = string.replace("l", "");
```

String 객체의 값을 변경하는 작업은 새로운 String 객체를 만들고 값을 복사하는 작업이 수행됨을 의미한다.

이러한 문제를 해결하기 위해 나온 것이 StringBuilder, StringBuffer 클래스이다.

> StringBuffer VS StringBuilder
>

Thread-Safe 가 없는 StringBuilder 클래스가 속도 측면에서 미세하지만 더 빠르므로 StringBuilder 를 사용하면 된다.

```java
StringBuilder sb = new StringBuilder();
sb.append(10);

sb.deleteCharAt(3)   // 3번째 인덱스 문자 삭제
sb.insert(1,2) // 1번째 인덱스에 2라는 문자 추가

```

> 메서드
>

```java
public int function_name(int param1, int param2){

	return result;
}
```

> 람다식(익명 함수)
>

코드에서 딱 한 번 실행할 목적으로 사용하거나 함수 자체를 다른 함수의 인수로 전달할 떄 사용

간결하고 가독성이 좋아진다.

```java
Arrays.sort(nodes, (o1,o2) -> Integer.compare(o1.cost, o2.cost));
```

> 코딩 테스트 코드 구현 노하우
>
- 조기 반환 : 코드 실행 과정이 함수 끝까지 도달하기 전에 반환하는 기법

```java
if(total > 100)
	return (int)(total * 0.9 );
```

함수 자체를 조기에 종료할 수 있으므로 예외에 대한 처리를 하지 않아도 된다.

- 보호 구문 : 본격적인 로직을 진행하기 전 예외 처리 코드를 추가하는 기법

```java
if (numbers == null) return 0;
if (numbers.isEmpty()) return 0;

//예외 처리 후 구현
... 구현부 ...
```

- 제네릭 : 빌드 레벨에서 타입을 체크하여 타입 안정성을 제공하고, 타입 체크와 형변환을 생략할 수 있게 해줌. ( 다양한 데이터 타입을 처리할 수 있게 해준다)

```java
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

List<Integer> genericList = new ArrayList<>();
List<String> genericList2 = new ArrayList<>();
```

코딩 테스트 에서 여러 타입의 데이터를 하나의 컬렉션에 넣어야 하는 경우는 거의 없다.